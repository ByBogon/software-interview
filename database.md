## Database

- 인덱스는 왜 필요한가

  > 먼저 인덱스는 검색에 최적화된 기능
  > 인덱스가 없다면 특정 값을 찾을때 전체데이터를 조회하고 값을 반환하기때문에 트래픽에 따라 성능이 저하될 수 밖에 없음
  > 그래서 이러한 점을 방지하고자 인덱스를 자주 조회되는 컬럼에 걸면, 해당 컬럼의 인덱스 테이블이 생성되고 해당 컬럼에 대한 where 문의 포함된 쿼리가 나갈때 해당 인덱스 테이블에 저장된 키 밸류 값을 참조해서 해당 테이블에서 결과 값을 반환
  > 인덱스 테이블에서 where 에 포함된 값 찾음 → 해당 값의 pk 가져옴 → 가져온 pk 값으로 원본 테이블에서 값 조회
  > mysql innodb는 기본적으로 b+ tree 알고리즘으로 인덱스를 관리

- 디비에 인덱스를 걸때 해당 컬럼이 string 계열이고 길이가 너무 길면 느려지는데 왜 느려질까?

  > 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 하며, 인덱스 역시 페이지 단위로 관리됩니다. 페이지는 16KB 로 고정 되어있을때, 만약 인덱스 키의 크기가 16byte, 자식노드의 주소가 담긴 크기가 12byte 정도로 잡으면 16*1024 / (16+12) = 585 로 인해 하나의 페이지에는 585개가 저장 될 수있음. 그러나 인덱스 키가 32byte가 되면 16*1024 / (32+12) = 372 로 되어 375개만 한 페이지에 저장 가능.
  > 조회 결과로 500개의 row를 읽을때 16byte일때는 1개의 페이지에서 다 조회가 되지만, 32byte일때는 2개의 페이지를 읽어야 하므로 이는 성능 저하가 발행하게 됩니다.
  > **인덱스의 키는 길면 길수록 성능상 이슈가 있음**

- Mysql innodb에서 Primary key 는 왜 unique index key 보다 더 빠를까?

  > - 디스크에 데이터를 저장할 때 pkey 기준으로 저장하다보니 pkey로 그냥 데이터에 바로 접근 가능하기 때문에
  > - 인덱스는 인덱스 테이블을 만들어서 검색에 활용되다보니 데이터에 바로 접근하는 pkey 보다는 조금이나마 더 느릴것 같음 (확인 필요)

- 디비에 락의 종류가 테이블락과 로우 락이 있는데 설명
  > - 테이블락: 테이블을 기준으로 Lock을 설정. 이는 테이블의 모든 행을 업데이트 하는 등의 전체 테이블에 영향을 주는 변경을 수행할 때 유용함. 즉, **DDL(Data Definition Language) (create, alter, drop 등) 구문과 함께 사용되며 DDL Lock 이라고도 함**
  > - 로우(Row) 락: 행 수준의 Lock은 1개의 행을 기준으로 Lock을 설정. DML (Data Manipulation Language) 에 대한 Lock으로 가장 일반적으로 사용되는 Lock.
