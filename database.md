## Database

- 인덱스는 왜 필요한가

  > - 먼저 인덱스는 검색에 최적화된 기능
  > - 인덱스가 없다면 특정 값을 찾을때 전체데이터를 조회하고 값을 반환하기때문에 트래픽에 따라 성능이 저하될 수 밖에 없음
  > - 그래서 이러한 점을 방지하고자 인덱스를 자주 조회되는 컬럼에 걸면, 해당 컬럼의 인덱스 테이블이 생성되고 해당 컬럼에 대한 where 문의 포함된 쿼리가 나갈때 해당 인덱스 테이블에 저장된 키 밸류 값을 참조해서 해당 테이블에서 결과 값을 반환
  > - 인덱스 테이블에서 where 에 포함된 값 찾음 → 해당 값의 pk 가져옴 → 가져온 pk 값으로 원본 테이블에서 값 조회
  > - mysql innodb는 기본적으로 b+ tree 알고리즘으로 인덱스를 관리

- 디비에 인덱스를 걸때 해당 컬럼이 string 계열이고 길이가 너무 길면 느려지는데 왜 느려질까?

  > - 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 하며, 인덱스 역시 페이지 단위로 관리됩니다. 페이지는 16KB 로 고정 되어있을때, 만약 인덱스 키의 크기가 16byte, 자식노드의 주소가 담긴 크기가 12byte 정도로 잡으면 16*1024 / (16+12) = 585 로 인해 하나의 페이지에는 585개가 저장 될 수있음. 그러나 인덱스 키가 32byte가 되면 16*1024 / (32+12) = 372 로 되어 375개만 한 페이지에 저장 가능.
  > - 조회 결과로 500개의 row를 읽을때 16byte일때는 1개의 페이지에서 다 조회가 되지만, 32byte일때는 2개의 페이지를 읽어야 하므로 이는 성능 저하가 발행하게 됩니다.
  >   **인덱스의 키는 길면 길수록 성능상 이슈가 있음**

- Mysql innodb에서 Primary key 는 왜 unique index key 보다 더 빠를까?

  > - 디스크에 데이터를 저장할 때 pkey 기준으로 저장하다보니 pkey로 그냥 데이터에 바로 접근 가능하기 때문에
  > - 인덱스는 인덱스 테이블을 만들어서 검색에 활용되다보니 데이터에 바로 접근하는 pkey 보다는 조금이나마 더 느릴것 같음 (확인 필요)

- 디비에 락의 종류가 테이블락과 로우 락이 있는데 설명

  > - 테이블락: 테이블을 기준으로 Lock을 설정. 이는 테이블의 모든 행을 업데이트 하는 등의 전체 테이블에 영향을 주는 변경을 수행할 때 유용함. 즉, **DDL(Data Definition Language) (create, alter, drop 등) 구문과 함께 사용되며 DDL Lock 이라고도 함**
  > - 로우(Row) 락: 행 수준의 Lock은 1개의 행을 기준으로 Lock을 설정. DML (Data Manipulation Language) 에 대한 Lock으로 가장 일반적으로 사용되는 Lock.

- 인덱스 특징

  > - 인덱스 테이블
  >   > 인덱스는 하나의 테이블을 생성해 값을 저장해 놓고 사용한다. 그래서 다른 테이블에 의존적인 새로운 테이블이 하나 생성된다는 점에서 무분별한 인덱스 생성은 오히려 성능 저하를 초래할 수 있다.
  > - 정렬
  >   > 인덱스 테이블은 이진트리 검색(B+ tree)를 사용하기 때문에 기본적으로 정렬되어있다. 그래서 만약 인덱스 테이블이 참조하는 테이블에서 삽입, 삭제, 수정이 자주 일어나게 된다면 인덱스 테이블에서는 데이터를 정렬하면서 삽입, 삭제, 수정이 이루어지기 때문에 전체적인 성능 저하를 초래할 수 있다.

- 인덱스를 설정하는 기준
  > - 1개의 컬럼
  >   > 1개의 컬럼만 인덱스를 걸어야 한다면, 해달 컬럼은 카디널리티가 가장 높은것을 잡아야함(카디널리티는 해당 컬럼의 중복된 수치, 예를 들면 성별, 학년 등은 카디널리티가 낮고 주민번호, 계좌번호 등은 카디널리티가 높음).
  >   > 인덱스로 최대한 효율을 뽑아내려면, **해당 인덱스로 많은 부분을 걸러내야 하기 때문**입니다.만약 성별을 인덱스로 잡는다면, 남/녀 중 하나를 선택하기 때문에 인덱스를 통해 50%밖에 걸러내지 못합니다.하지만 주민등록번호나 계좌번호 같은 경우엔 **인덱스를 통해 데이터의 대부분을 걸러내기 때문에** 빠르게 검색이 가능합니다.
  > - 여러개의 컬럼
  >   > - 여러 컬럼으로 인덱스 잡을때의 인덱스 순서
  >   >   - 카디널리티가 높은순에서 낮은순으로 구성하는게 더 성능이 뛰어남
  >   > - 여러 컬럼으로 인덱스시 조건 누락
  >   >   - 조회 쿼리 사용시 인덱스를 태우려면 최소한 **첫번째 인덱스 조건은 조회조건에 포함** 되어야만 합니다. 첫번째 인덱스 컬럼이 조회 쿼리에 없으면 인덱스를 타지 않는다는 점을 기억하시면 됩니다.
